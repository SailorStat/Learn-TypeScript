//? Совместимость типов
// Совместимость типов в TS основана на структурных подтипах. Структурная типизация - это способ связывания
// типов исключительно на основе их членов. Это контрастирует с нормальной типизацией. Рассмотрим код:
{
  interface Pet {
    name: string
  }

  class Dog {
    name: string
    constructor(s?: string) {
      this.name = s || ""
    }
  }

  let pet: Pet
  pet = new Dog()
}
// В языках с номинальной типизацией такая запись будет ошибкой, так как Dog явно не наследуется от Pet

// Система структурных типов TS была разработана на основе того, как обычно пишется код JS. Поскольку в JS
// широко используются анонимные объекты, такие как функциональные выражения и объектные литералы,
// гораздо естественнее предсавлять виды отношений, обнаруженные в библиотеках JS, системой структурных
// типов вместо номинальной


//* Примечание о надёжности
// Система типов TS позволяет выполнять определённые операции, о которых невозможно узнать во время
// компиляции. Когда система типов имеент это свойство, она считается "ненадёжной". Места, где TS допускает
// ненадлежащее поведение, были тщательно рассмотрены, и в этом документе мы объясним, гед это происходит,
// и мотивирающие сценарии, стоящие за ними.


//* Начинающийся
// Основное правило для системы структурных типов TS х - совместимость с  y if y  имеет как минимум те же
// члены, что и x. Например, рассмотрим следующий код, включающий интерфейс с именем, у Pet которого есть
// name свойство
{
  interface Pet {
    name: string
  }
  let pet: Pet
  let dog = {name: "lessie", owner: "Rudd Weatherwax"}
  pet = dog
}

// Чтобы проверить, что dog можно присвоить pet, компилятор проверяет каждое свойство pet, чтобы найти
// соответстующее совместимое свойство в dog. В этом случае dog должен быть назван член, name которого
// является строкой. Это так, поэтому присвоение разрешено

// Это провило наботает и на присвоение аргументов функции

// Дополнительное свойство owner у dog не создаёт ошибки, так как проверка идёт только по целевым свойствам
// у интерфейса Pet

// Этот процесс идёт рекурсивно, исследуя тип каждого члена и подчлена


//* Сравнение двух функций
// Хотя сравнение примитивных типов и типов объектов относительно просто, вопрос о том, какие типы функций
// следует считать совместимыми, немного сложнее. Начнём с базового примера двух функций, которые
// различаются только списками парметров
{
  let x = (a: number) => 0
  let y = (a: number, s: string) => 0
  y = x
  // x = y    - ошибка, х не модет принять переменную s из у
}
// Чтобы присвоение работало, надо чтобы принимающая функция могла обработать все перменные из присваивающей
// При этом не имеют значение названия переменных. Важны только типы

// Если параметр необязательный, то он отбрасывается
{
  const items = [1, 2, 3]
  items.map((value, index, array) => console.log(value))
  // тоже, что и
  items.map((value) => console.log(value))
}

// Теперь давайте посмотрим, как обрабатываются возвращаемые тип, используя эти две функции, которые
// отличаются только своим возвращаемым типом
{
  let x = () => ({name: "Alice"})
  let y = () => ({name: "Alice", location: "Seattle"})
  x = y
  // y = x    - ошибка, поведение возвращаемого значения не может быть сужено
}


//* Двувариантность функциональных парметров
// При сравеннии типов параметров функции назначение считается успешным, если исходный парметр может быть
// назначен целевому параметру, или наоборот. Это необоснованно, потому что вызывающей стороне может быть
// предоставлена функция, которая принимает более специализированный тип, но вызывает функцию с менее
// специализированным типом. На практике ошибки такого рода встречаются редко, и это позволяет использовать
// многие распространённые шаблоны JS
{
  enum EventType {
    Mouse,
    Keyboard
  }
  interface Event {
    timestamp: number
  }
  interface MyMouseEvent extends Event {
    x: number
    y: number
  }
  interface MyKeyEvent extends Event {
    keyCode: number
  }
  function listenEvent(eventType: EventType, handler: (n: Event) => void) {}

  // listenEvent(EventType.Mouse, (e: MyMouseEvent) => console.log(e.x + "," + e.y))

  listenEvent(EventType.Mouse, (e: Event) =>
    console.log((e as MyMouseEvent).x + ", " + (e as MyMouseEvent).y)
  )

  // listenEvent(EventType.Mouse, ((e: MouseEvent) => console.log(e.x + "," + e.y)) as (e: Event) => void)

  // listenEvent(EventType.Mouse, (e: number) => console.log(e))
}
// Ошибки возникают из-за флага компилятора strictFunctionTypes


//* Необязательные параметры и параметры rest
// При сравнении функций на совместимость необязательные и обязательные параметры взаимозаменяемы.
// Дополнительные и необязательные параметры исходного типа не являются ошибкой, а необязательные
// парметры целевого типа без соответствующих параметров в исхожном типе не являются ошибкой

// Когда функция имеет парметр rest, она рассматривается как бесконечная серия необязтальных параметров.

// Это неразумно с точки зрения системы типов, но с точки зрения времени выполнения идея необязательного
// парметра обычно не применяется, поскольку передача undefined в этой позиции эквивалентна для большинства
// функций

// В качестве мотивирующего примера можно привести общий образец функции, которая принимает обратный вызов
// и вызывает его с некоторым предсказуемым (для програмиста), но неизвестным (для системы типов) числом
// аргументов
{
  function invokeLater(args: any[], callback: (...args: any[]) => void) {}

  invokeLater([1, 2], (x, y) => console.log((x + ", " + y)))
  invokeLater([1, 2], (x?, y?) => console.log((x + ", " + y)))
}


//* Функция с перегрузками
// Когда функция имеет перегрузки, каждая перегрузка в исходном типе должна соответствовать совместной
// сигнатуре целевого типа. Это гарантирует, что целевая функция может быть вызвана во всех ситуациях, что
// и исходная функция


//* Перечисления
// Перечисления совместимы с числами и наоборот. Значения перечислений из разных типов перечислений
// считаются несовместимыми
{
  enum Status {
    Ready,
    Waiting
  }
  enum Color {
    Green,
    Red,
    Blue
  }
  let status = Status.Ready
  // status = Color.Green   - ошибка
}


//* Классы
// Классы работают аналогично типам объектных литералов и интерфейсам с одним исключением: они имеют как
// статический, как и экземплярный тип. При сравнении двух объектов типа класса сравниваются только члены
// экземпляра. Статические члены и конструкторы не влияют на совместимость
{
  class Animal {
    feet: number
    constructor(name: string, numFeet: number){
      this.feet = numFeet
    }
  }
  class Size {
    feet: number
    constructor( numFeet: number){
      this.feet = numFeet
    }
  }
  let a: Animal
  let s: Size
  // a = s
  // s = a
}


//* Частные и защищённые члены в классах
// Частные и защищённые члены в классе влияют на их совместимость. Когда экземпляр класса проверяется на
// совместимость, если целевой тип содержит закрытый член, тогда исходный тип также должен содержать
// закрытый член, происходящий из того же класса. Точно так же то же самое относится к экземпляру
// с защищённым членом. Это позволяет классу быть совместимым по назначению со своим суперклассом, но
// не классами из другой иерархии наследования, которые в остальном имеют ту же форму


//* Дженерики
// Поскольку TS является системой структурных типов, параметры типа влияют на результирующий тип, только
// если они используются как часть типа члена. Например:
// interface Empty<T> {}
// let x = Empty<number>
// let y = Empty<string>
// x = y

// В приведённом выше  х и у  совместимы, потому что структуры не используют аргумент типа дифференцирующим
// образом. При изменении примера будет видно, как это работает
// interface Empty<T> {
//   data: T
// }
// let x = Empty<number>
// let y = Empty<string>
// x = y

// Таким образом, универсальный тип, для которого указаны аргументы типа, действует так же, как
// неуниверсальный тип

// Для универсальных типов, для которых не указаны аргументы типа, совместимость проверяется путём указания
// any вместо всех неуказанных аргументов типа. Затем полученные типы проверяются на совместимость, как и в
// неуниверсальном случае

// Например
{
  let identity = function <T>(x: T): T { return x }

  let reverse = function <U>(x: U): U { return x }
  identity = reverse
}


//* Продвинутые темы
//* Подтип против присвоения
// До сих пор мы использовали термин "совместимый", который не оперделён в спецификации языка. В TS есть
// два типа совместимость: подтип и присваивание. Они отличаются только тем, что присваивание расширяет
// совместимость подстипов с помощью правил, позволяющих присваивать соответствующие числовые значения, а 
// такде от any и до enum

// В разных местах языка используется один из двух механизмов совместимости, в зависимости от ситуации.
// Для практических целей, совместимость типа продиктована совместимостью назначения, даже в тех случаях, из
// implements и extends положений

//* Any, unknow, object, void, undefined, null и never назначаемость
// В слудующей таблице приводится сводная информация о назначении между некоторыми абстрактными типами.
// Строки указывают, что каждый из них может быть назначен, столбцы указывают, что им можно назначить
// Галочка указывает на совместимость только в выключенном --strictNullChecks
// /https://www.typescriptlang.org/docs/handbook/type-compatibility.html

// Основы:
// - все присваиваются себе
// - any и unknow одинаковы с точки зрения того, что им присваивается, отличаются тем, что unknow не
//   присваивается ничему, кроме any
// - unknow и never подобны противоположностям. Всё присвоивается unknow, never присваивается всему.
//   Ничто не может быть назначено never, unknow не может быть назначено ни на что (кроме any)
// - void не может быть назнчаен или от чего-лобо, со следующими исключениями: any, unknown, never,
//   undefined, и null (если --strictNullChecksвыключен, смотрите таблицу для деталей)
// - Когда --strictNullChecksвыключено nullи undefinedаналогично never: присваивается большинству
//   типов, большинство типов им не присваивается. Они назначаются друг другу.
// - Когда --strictNullChecksвключен, nullи undefinedвести себя , как void: не может быть передано
//   или от чего - либо, за исключением any, unknown, neverи void( undefinedвсегда присваиваемые void).