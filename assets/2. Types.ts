//? Определение типов в TS
//* Примитивы
// number, string, boolean

// массив определённых типов указывается так: number[] или Array<number>

// когда нет желания получить ошибку типа, и не определён тип, следует использовать any
// каждый раз, когда значение не определено, TS определяет значение, как any
// режим noImpicitAny указыает на any каждый раз, как на ошибку


// * Аннотация типов к переменным
// Каждый раз при указании переменной, к ней можно указать аннотацию типа
const appleVariety: string = "Антоновка"
// Обычно этого не требуется, так как TS сам определит тип при инициализации
let storyBookPerson = "Красная шапочка"


//* Аннотации к функциям
// В функциях аннотацию можно делать и для входных параметров и для параметров на выходе
// аннотация входных параметров
function greet(name: string) {
  console.log(`${name}, my heard is glad to see you`)
}
// такая функция примет только строку в виде параметра или выдаст ошибку
// greet(42)
// функция в любом случае проверит количество аргументов

// При создании функции можно указать тип возвращаемого значения, однако это не требуется
// TS самостоятельно определит тип на основе return операторов
function sum(a, b): number {
  return a + b
}
// Но никто не запрещает это делать

// Контекстная типизация позволяет определять тип на основании переданных данных


//* Типы объектов
// Для определения типа надо указать объект и типы его обязательных значений
interface arrow {
  speed: number
  lenght: number
  weight: number
}

// Чтобы указать, что свойство не обязательное, после названия надо поставить ?
interface Pie {
  width: number
  lenght: number
  filling?: string
}
const firstPie: Pie = { width: 12, lenght: 12 }
// Перед использованием необязательного свойства его нужно проверить на undefined


//* Типы союзов
// Когда определено несколько типв, их можно комбинировать
// Союз объединения делается через |
function log(param: number | string) {
  console.log(param)
}

// Под сужением понимают разделение действий в зависимости от тимпа
function bigLog(param: number | string) {
  if (typeof param === "string") {
    console.log(param.toUpperCase())
  } else console.log(param)
}

// Если члены союза имеют общий метод, то сужение проводить не нужно
function shreder(param: number[] | string) {
  console.log(param.slice(0, 3))
}

// Очень удобро использовать создание типа, когда один тип будет переиспользоваться
type ID = string | number

// Создание интерфейса можно использовать почти точно также
interface horse { title: string | number }
// основное отличие, что интерфейс можно расширять и наследовать
interface horse { nickname: string }


// Для создания союзов можно использовать литералы
// Литералы - фиксированные значения
// Записывать в правило один литерал нет смысла, так как такое замение нельзя поменять
// Зато комбинация может быть очень полезна
let schoolGrades: 1 | 2 | 3 | 4 | 5 = 5
schoolGrades = 2

// Литералы можно комбинировать с типами и интерфейсами
type schoolGradesType = 1 | 2 | 3 | 4 | 5
let ukrainianSchoolGrades: schoolGradesType | 6 | 7 | 8 | 9 | 10 | 11 = 8


// Буквальный вывод
// чтобы присвоить значение объекта, как константу, надо воспользованаться as *const*
const obj = { counter: 0 as 0 }
// obj.counter = 1 - ошибка
// Это гарантирует, что переменная будет восприниматься "как есть", а не number или string


// null и undefined применяются, когда значение неизвестно
// В зависимости от опции strictNullChecks изменяется поведение

// strictNullChecksопция - выключен
// undefined и null могут быть присвоены любому значению
// Значения надо обязательно проверять на !==, чтобы избежать ошибок

// strictNullChecksопция - включен
// переменные обязательно нужно проверять перед использованием


// Ненулевой оператор утверждения
// если мы точно уверены в неравенстве null или undefined
// то без дополнительных проверок можем это обозначить !
const func = (value: number | null) => {
  console.log(value!.toFixed())
}


// Перечисления - https://www.typescriptlang.org/docs/handbook/enums.html

// Редкие примитивы: bigint и symbol