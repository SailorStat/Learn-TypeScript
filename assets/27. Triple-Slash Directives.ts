//? Директивы с тройной косой чертой
// Директивы с тройной косой чертой (ТКЧ) - это однострочные комментарии, содержащие один тег XML
// Содержимое комментария используется как директива компилятора

// Директивы с ТКЧ действительны только вверху содержащего из файла. Директиве с ТКЧ могут предшествовать
// только одномтрочные и многострочные комментарии, включая директивы с ТКЧ. Если они встречаются после
// оператора или объявления, они рассматриваются, как обычные однострочные комментарии и не имеют значения

/// Директива <reference path="..."/> является наиболее распространённой из этой группы. Он служит
// декларацией зависимости между файлами

// Ссылки с ТКЧ инструктируют компилятор включать дополнительные файлы в процесс компиляции.

// Они также служат методом упорядочивания вывода при использовании --out или --outFile. Файлы отправляются
// в расположение выходного файла в том же порядке, что и входные, после прохода предварительной обработки


//* Предварительная обработка входных файлов
// Компилятор выполняет предварительную обработку входных файлов для разрешения всех ссылочных директив с
// ТКЧ. Во время выполнения этого процесса к компиляции добавляются дополнительные файлы.

// Процесс начинается с набора корневых файлов. Это имена файлов, указанных в командной строке или в "files"
// списке в tsconfig.json файле. Эти корневые файлы предварительно обрабатываются в том же порядке, в
// котором они указаны. Прежде чем файл будет добавлен в список, все ссылки с ТКЧ в нём обрабатываются,
// включая их целевые объекты. Ссылки с ТКЧ разрешаются в первую очередь в глубину в том порядке, в котором
// укааны в файле

// Путь ссылки с ТКЧ разрешается относительно содержащего файла, если используется относительный путь


//* Ошибки
// Ссылка на несуществующий файл является ошибкой. Ссылка на файл с ТКЧ является ошибкой


//* С использованием --noResolve
// Если --noResolve указан флаг компилятора, ссылки с ТКЧ игнорируются, они не приводят ни к добавлению
// новых файлов, ни к изменению порядка предоставленных файлов


//* /// <reference types="..." />
// Подобно /// <reference path="..." /> директиве, которая служит объявлением зависимости,
// директива /// <reference types="..." /> объявляет зависимость от пакета

// Процесс разрешения этих имён пакетов аналогичен процессу разрешения имён модулей в import операторе.
// Директивы типов с ТКЧ и ссылочными типами проще всего рассматривать, как import пакеты для объявлений

// Например, включение /// <reference types="node" /> в файл значит, что этот файл использует имена,
// объявленные в @types/node/index.d.ts и по-этому этот пакет необходимо включить в компиляцию вместе с
// файлом объявления

// Использовать эти директивы стоит только при создании .d.ts файла в ручную

// Для файлов объявлений, созданных во время компиляции, компилятор автоматически добавит их /// <reference
// types="..." />. А в сгенерированном добавляется только тогда, когда в результирующем файле используются
// какие-то объявления из указанного пакета

// Чтобы объявлить зависимость от @types пакета в .ts файле, используйте его --types в командной строке
// или в вашем файле tsconfig.json


//* /// <reference lib="..." />
// Эта директива позволяет файлу явно включать существующий встроенный файл lib

// На встроенные файлы lib ссылаются так же, как на "lib" параметр компилятора в tsconfig.json (например,
// использовать lib="es2015", а не использовать lib="lib.es2015.d.ts" и т.д.)

// Для авторов файлов объявлений, которые полагаются на встроенные типы, например, DOM API или встроенные
// конструкторы времени выполнения JS, такие как Symbols или Iterable, рекомендуются директива lib с ТКЧ.
// Раньше эти файлы .d.ts приходилось добавлять прямые / повторяющиеся объявления таких типов.

// Например, добавление /// <reference lib="ex2017.string" /> к одному из файлов компиляции эквивалентно
// компиляции с использованием --lib es2017.string
/// <reference lib="es2017.string" />
"foo".padStart(4)


//* /// <reference no-default-lib="true" />
// Эта директива отмечает файл как библиотеку по умолчанию. Вы увидите этот комментарий вверху lib.d.ts и
// его различные варианты

// Эта директива указывает компилятору не включать библиотеку по умолчанию (т.е. lib.d.ts) в компиляцию.
// Воздействие здесь похоже на передачу --noLib в командной строке

// Также обратите внимание, что при передаче --skipDefaultLibCheck компилятор пропускает проверку только
// файлов с расширением /// <reference no-default-lib="true" />


//* /// <amd-module />
// По умолчанию модули AMD генерируются анонимно. Это может привести к проблемам, когда для обработки
// полученных модулей имспользуются другие инструменты, такие как сборщики (например r.ts)

// Директива amd-module позволяет пропускание необязательного имени модуля для помпилятора

// amdModule.ts
/// <amd-module name="NamedModule">
export class C{}
// Приведёт к присвоению имени NamedModule модулю, как части вызова AMD define:

// amdModule.js
// define("NamedModule", ["require", "exports"], function (require, exports) {
//   var C = (function () {
//     function C() {
//       return C
//     }
//   })()
//   exports.C = C
// })


//* /// <amd-dependency />
//todo эта конструкция устарела. Следует использовать import "moduleName"
// Директива /// <amd-dependency path="x" /> информирует компилятор о зависомости модуля, отличного от TS,
// который необходимо ввести в результирующий вызов модуля require

// Директива amd-dependency может иметь дополнительные name-собственности, это позволяет передавать
// необязательное имя для amd-зависимости
/// <amd-dependency path="legacy/moduleA" name="moduleA" />
// declare var moduleA: MyType
// moduleA.callStuff()

// Сгенерированный код JS
// define(["require", "exports", "legacy/module"], function (require, exports, ModuleA) {
//   ModuleA.callStuff()
// })