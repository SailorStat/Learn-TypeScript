//? Вывод типа
// В TS есть несколько мест, где вывод типа испольуется для предоставления информации о типе, когда нет
// явной аннотации типа
{
  let x = 1 // - тип number
}
// Этот вид вывода имеет место при инициализации переменных и членов, установке значений параметров по
// умолчанию и определении типов возвращаемых функций

// В большинстве случаев вывод типа прост. В следующих разделах мы исследуем некоторые нбансы вывода типов


//* Лучший общий тип
// Когда вывод типа выполняется из нескольких выражений, типы выражений используются для вычисления
// лучшего общего типа
{
  let x = [0, 1, null]  // (number | null)[]
}
// Здесь рассматривается тип каждого элемента, после чего каждый новый тип добавляется в общий тип

// Поскольку лучший общий тип должен быть выбран из кандидатов, в некторых случаях они имеют общую
// структуру, так как нет супертипа для всех кандидатов
{
  let something = [new Error(), new Date(), new String()]
}

// Если нам надо обозначить свой тип из такого выражения, то должны добавить так
{
  type Something = Error | Date | String
  let something: Something[] = [new Error(), new Date(), new String()]
}
// Иначе TS выведет лючший общий тип


//* Контекстный ввод
// В TS в некоторых случаях вывод типа также работает в обратном порядке. Это известно, как контекстная
// типизация. Контекстная типизация происходит, когда выражение подразумевается его местонахождением
{
  window.onmousedown = function (mouseEvent) {
    console.log(mouseEvent.button)
  }
}
// Здесь TS по контексту присвоения для window.onmousedown определил свойства у mouseEvent

// Это работает, потому что window.onmousedown уже определено в своём типе
{
  let window: Window & typeof globalThis

  interface Window extends GlobalEventHandlers {}

  interface GlobalEventHandlers {
    onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null
  }
}
// И TS умный, чтобы понять, какие должны быть типы

// Изменяет это поведение --noImplictAny опция

// Также можно явно предоставить информацию о типе аргемента функции, чтобы предопределить тип
{
  window.onscroll = function (uiEvent: any) {
    console.log(uiEvent.button)
  }
}
// Этот код будет регистрироваться, как undefined, так как у uiEvent не будет свойства button

// Контекстная типизация принимается во многих случаях. Общие случаи включают аргументы и операторы
// возврата. Контекстный тип также действует, как тип-кандидат в наиболее растространённом типе
{
  type Something = Error | Date | String
  function createSomething(): Something[] {
    return [new Error(), new Date(), new String()]
  }
}
// Здесь у лучшего типа набор из четырёх кандидатов: Something, Error, Date, String. Из них можно выбрать
// Something как лучший общий тип