//? Объявление переменной
// let и const являются двумя относительно новыми концепциями переменных в JS

// let создаёт переменную, а const расширяет это поведение, запрещая повторное присвоение


//* var объявление
var numb = 3


//* Правила определения объёма
// var объявления имеют некоторые странные правила области видимости для тех, которые используются для
// других языков
// function f(shouldInizialize: boolean) {
//   if (shouldInizialize) {
//     var x = 10
//   }
//   return x
// }

// Перменная x была объявлена внутри if блока, но мы смогли получить к ней доступ извне этого блока. Это
// потому, что var объявления доступны где угодно в пределах их содержащей функции, модуля, пространства
// имён или глобальной области видимости независимо от содержащего блока. Некоторые люди называют это
// varосмотром или определением функции. Параметры также зависят от функции

// Эти правила определния объёма могут привести к нескольким типам ошибок. Одна проблема, которую они
// усугубляют, закобчается в том, что не является ошибкой объявлять одну и ту жу переменную несколько раз
function sumMatrix(matrix: number[][]) {
  var sum = 0
  for (var i = 0; i < matrix.length; i++) {
    var currentRow = matrix[i]
    for (var i = 0; i < currentRow.length; i++) {
      sum += currentRow[i]
    }
  }
}

// Внутренний for случайно перезапишет переменную i поскольку она относится к той же пременной с областью
// действия. Подобные ошибки проскакльзывают при проверке кода и могут стать бескоченым источником
// разочарования.


//* Причуды переменного захвата
// Вот такой код
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i)
  }, 100 * i)
}
// вернёт
5
5
5
5
5

// Каждое выражение функции setTimeout, которое мы передаём, относится к ододному и тому же i из общей
// области видимости

// Давайте посмотрим, что это значит. setTimeout запустит функцию через некоторое количество миллисекунд,
// но только после того, как for цикл перемтанет выполняться. К тому времени, когда for цикл перестанет
// выполняться, значение i равно 10. Таким образом каждый раз распечатывается 5

// Обычный путь - использовать выражение IIFE - выражение немедленного вызова функции - для захвата i на
// каждой итерации
for (var i = 0; i < 5; i++) {
  (function (i) {
    setTimeout(function () {
      console.log(i)
    }, 100 * i)
  })(i)
}
// В списке параметров i затеняет i из for цикла, но, поскольку мы назвали из одинаковыми, нам не пришлось
// слишком сильно изменять тело цикла


//* let объявление
// Из-за проблем var был введён let. За искобчением исключением ключевого слова используется также
{
  let hello = "hello"
}
// Ключевое различие в семантике


//* Блочная область видимости
// Когда пременная объявляется через let, она использует то, что некоторые называют лексической областью
// видимости или блочной областью видимости. В отличие от объявленных переменных var, чья область видимости
// просачивается в содержащую его функцию, переменные с блочной областью видимости не видны за пределами
// близжайшего к ним содержащего блока или for-области
{
  function f(input: boolean) {
    let a = 100
    if (input) {
      let ba = a + 1
      return ba
    }
    // return ba    - ошибка, ba нет
  }
}

// Переменные, объявленные в catch предложении, также имеют аналогичные правила области видимости
try {
  throw "oh no!"
} catch (e) {
  console.log("Oh well.")
}
// console.log(e)   - ошибка, е не найдено

// Ещё одно свойство переменных с блочной областью видимости заключается в том, что они не могут быть
// прочитаны или записаны до того, как они будут фактически объявлены. Хотя эти перменные присутствуют во
// всей их области видимости, все точки до их объявления считаются временной мёртвой зоной. Это изощрённый
// способ сказать, что переменную нельзя имспользовать до let объявления
{
  // ar++   - ошибка
  let ar
}

// Следует отметить, что всё ещё можно захватить перменную с блочной областью видимости до её объявления.
// Единственная загвоздка в том, что вызвать эту функцию перед объявлением запрещено. Если нацелены на
// ES5, то среда выполнения выдаст ошибку, современный TS допускает это и ошибку не выдаст
{
  function foo() {
    return arb
  }
  foo()
  let arb = 1
}


//* Повторные объявления и затенение
// Что касается var объявлений, мы упоминали, что не имеет значения, сколько раз вы объявляли свои
// переменные
{
  function f() {
    var t
    var t
    if (true) {
      var t
    }
  }
}
// В этом примере все объявления относятся к одной переменной

// К счастью, let заявления не столь снисходительны
{
  let t = 10
  // let t = 20  - ошибка, переменная уже объявлена в этой области видимости
}

// Переменные не обязательно должны иметь блочную область видимости, чтобы TS сообщил о проблеме
{
  function f(x: number) {
    // let x = 100      - ошибка, переменная объявлена в аргументах функции
  }
  function g() {
    let x = 100
    // var x = 100      - для переменных с блочной областью видимости нельзя объявлять такую же переменную
    //                    в той же области видимости
  }
}

// Области видимости могут пересекаться, но не должны быть одинаковыми
{
  function f(boo: boolean, x: number) {
    if (boo) {
      let x = 100
      return x
    }
    return x
  }
}

// Акт введения нового имени в более вложенную область называется затенением. Оно может вносить и
// предотвращать ошибки. Нпример, представим, что мы ранее написали версию функцию sumMatrix c
// использованием let
{
  function sumMatrix(matrix: number[][]) {
    let sum = 0
    for (let i = 0; i < matrix.length; i++) {
      var currentRow = matrix[i]
      for (let i = 0; i < currentRow.length; i++) {
        sum += currentRow[i]
      }
    }
    return sum
  }
}
// Цикл отраобтает правильно, потому что внутренняя i затеняет внешнюю i, и у каждой остаётся своя область
// видимости

// Обычно стоит избегать затенения, но иногда это может быть полезным.


//* Захват переменных с блочной областью видимости
// Когда мы впервые коснулись идеи захвата переменных с помощью var, мы кратко рассмотрели, как действуют
// переменные после захвата. Чтобы лучше понять это, каждый раз при запуске области видимости создаётся
// среда переменных. Эта среда и её захваченные переменные могут сушествовать даже после того, как всё в
// её области завершено
{
  function theCityThatAlwaysSleeps() {
    let getCity
    if (true) {
      let city = "Seattle"
      getCity = function () {
        return city
      }
    }
    return getCity()
  }
}
// Поскольку мы захватили city из его среды, мы всё ещё можем получить к нему доступ, несмотря на то, что
// if блок завершил выполнение

// Напомним, что в нашем предыдущем примере setTimeout нам пришлось использовать IIFE для захвата состояния
// переменной для каждой итерации for цикла. По сути то, что мы делали, создавало новую среду переменных
// для наших захваченных перменных. Это было было неприятно, но больше этого делать не пидётся

// let объявления ведут себя по-разному, когда они объявляются, как часть цикла. Вместо того, чтобы просто
// вводить новую среду в сам цикл, эти объявления создают новую область видимости для каждой итерации.
// Посколько это то, что мы делали с IIFE, можно легко изменить наш старый пример
for (let i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i)
  }, 100 * i)
}
// и получим
1
2
3
4
5


//* const декларации
// const объявления - это ещё один способ объявления переменных
const numLivesForChat = 9

// Он похож на let, но не может быть переприсвоен после назначения, но при этом значения внутри присвоения
// могут быть изменены
{
  const example = [1, 23, 456]
  // example = [1, 23, 456, 7890]   - ошибка, переприсваивать нельзя
  example.push(7890)   //           - ошибки нет, изменилось внутреннее значение
}

// если внутреннее состояние тоже должно быть неизменно, то нужно использовать readonly
{
  interface ReadonlyNumberArr {
    readonly [s: number]: number
  }
  const example: ReadonlyNumberArr = [1, 23, 456]
  // example.push(7890)   - ошибка, нельзя изменять состояние
}


//* let или const
// Если переменная не должна быть перезаписана позднее, следует использовать const


//* Деструктуризация
//* Деструктуризация массива
let input = [1, 2]
let [first, second] = input
console.log(first) // 1
console.log(second) // 2

// Переменные могут поменяться значениями
// [first, second] = [second, first]

// С помощью rest-оператора можно собрать оставшиеся значения
{
  let [first, second, ...other] = [1, 2, 3, 4]
  console.log(other) // [3, 4]
}


//* Деструктуризация кортежа
// Кортежи можно деструктурировать, как массивы
{
  let example: [number, string, boolean] = [42, "42", true]
  let [a, b, c] = example
}
// При деструктуризации за пределами кортежа возникнет ошибка
// let [a, b, c, d] = example     - ошибка, example не имеет элемента с индексом 3

// Как и с массивами можно использовать rest-оператор

// Или игнорировать часть переменных
// let [, b] = example


//* Деструктуризация объекта
// Также можно деструктурировать объект
{
  let o = {
    a: "foo",
    b: 12,
    c: "bar"
  }
  let {a, b} = o
}

// Деструктуризацию может быть без объявления
// ({ a, b } = { a: "baz", b: 101 })

// Используя rest-оператор можно зоздать переменную для остальных элментов
{
  let {a, ...other} = { a: "foo", b: 12, c: "bar" }
  let total = other.b + other.c
}


//* Переименование собственности
// Свойствам можно дать разные имена. Двоеточие не указывает на тип
{
  let o = { a: "foo", b: 12, c: "bar" }
  let { a: newName1, b: newName2 } = o
}


//* Значения по умолчанию
// Помогают указать значение, если оно не передано
{
  function example(wholeObject: {a: string, b?: number}) {
    let {a, b = 42} = wholeObject
  }
}


//* Объявление функций
// Деструктуризация также работает в объявлении функций. Для простых случаев это просто
{
  type C = {a: string, b?: number}
  function f({a, b}: C): void {}
}

// Но указание значений по умолчанию более распространено для параметров и получить их может быть сложно
// Прежде всего нужен образец перед значением по умолчанию
{
  function f({a = "", b = 0} = {}): void { }
  f()
}
// Затем нужно не забыть указать значение по умолчанию для дополнительных свойств в деструктурированном
// свойстве вместо инициализатора. Помните, что это С было определено с помощью b

// Деструктуризацию нужно использовать осторожно. Даже с простой деструктуризацией параметров легко
// сбитьсяи сделать ошибку


//* REST
// Оператор распространения противоположен деструктуризации, он позволяет распространить массив на другой
// массив или объект на другой объект
{
  let first = [1, 2]
  let second = [3, 4]
  let bothPlus = [0, ...first, ...second] // [0, 1, 2, 3, 4]
}

// также работает с объектами
{
  let eat = {meat: "pig"}
  let nowEat = {}
}