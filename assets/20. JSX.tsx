//? JSX
//* Основное использование
// Чтобы использовать JSX нужно:
// 1. Назвать файлы .tsx расширением
// 2. Включить jsx опцию

// Машинопись поставляется с тремя режимами JSX: preserve, react и react-native
// Эти режимы влияют только на этап испускания - проверка типа не затрагивается

// Preserve режим будет сохранять JSX как часть вывода для дальнейшего использования
//  на другом этапе преобразования (например, Babel)
// Кроме того, у выходных данных будет .jsx расширение файла

// React режим будет создавать React.createElement, не нужно идти через трансформацию JSX перед использованием
// На выходе будет иметь .js разрешение файла

// React-native режим, как preserve сохраняет весь JSX, но на выходе будет .js файл

// Указать режим можно с помощью --jsx флага командной строки или соответствующей опцией jsx в файле
//  tsconfig.json

// Можно указать фабричную функцию JSX, которая будет использоваться при нацеливании на реакцию
//  JSX emit с --jsxFactory опцией (по умолчанию React.createElement)


//* as оператор
// Впомните, как написать утверждение типа
// var foo = <foo>bar

// Это утверждает, что переменная bar имеет тип foo
// Поскольку TS также использует угловые скобки для утверждения типа, объединение их с синтаксисом JSX
//  вызовет трудности при синтаксическом анализе
// В результатеугловые скобки не используются в .tsx файлах

// Вместо этого следует использовать as
// var foo = bar as foo
// одинаково работает и в .ts и в .tsx файлах


//* Проверка типа
// Чтобы понять проверку типов с помощью JSX, вы должны сначала понять разницу между внутренними элементами
//  и элементами, основанными на значениях. Учитывая выражение JSX <expr />, expr может относиться либо
//  к чему-то внутреннему для среды (например, к среде DOM div или span в среде DOM), либо к созданному
//  вами пользовательскому компоненту
// Это важно по двум причинам:
// 1. Для React внутренние элементы передаются, как strings (React.createElement("div")),
//    тогда как созданный вами компонент не (React.createElement(MyComponent))
// 2. Типы атрибутов, передаваемых в элементе JSX, следует искать по-другому. Внутренние атрибуты элемента
//    должны быть известны внутренне, тогда как компоненты, вероятно, захотят указать свой собственный
//    набор аргументов

// TS использует тоже соглашение, что и React, для их различения. Внутренний элемент всегда начинается со
// строчной буквы, а элемент, основанный на значении, всегда начинается с прописной буквы


//* Внутренние элементы
// Внутренние элементы ищутся в специальном интерфейсе JSX.IntrinsicElements. По умолчанию,
//  если этот интерфейс не указан, всё работает, а внутренние элементы не проверяются по типу
// Однако, если этот интерфейс присутствует, то имя внутреннего элемента ищется, как свойство на
//  JSX.IntrinsicElements интерфейсе
// declare namespace JSX {
//   interface IntrinsicElements {
//     foo: any
//   }
// }
// <foo />   - должно работать
// <bar />   - должна быть ошибка
// <bar /> приводит к ошибке, поскольку он не указан, как JSX.IntrinsicElements

// Индексатор строк для приёма всей почты домена JSX.IntrinsicElements можно указать так:
declare namespace JSX {
  interface IntrinsicElements {
    [elemName: string]: any
  }
}


//* Ценностно-ориентированные элементы
// Элементы, основанные на значениях, просто ищутся по идентификаторам,
//  которые находятся в области видимости
// import MyComponent from "./myComponent"
// <MyComponent />          - нормально
// <SomeOtherComponent />   - нет такого компонента

// Есть два способа определить элемент, основанный на значении
// 1. Функциональный компонент
// 2. Классовый компонент

// Поскольку эти два типа на основе значений неотличимы друг от друга в выражении JSX, сначала TS пытается
// разрешить выражение как функциональный компонент, испольуя разрешение перегрузки.
// Если процесс завершится успешно, TS завершает преобразование выражения в сво объявление
// Если значение не удаётся разрешить, как функциональный компонент, TS пытается разрешить, как компонент
// класса. Если это не удастся, TS сообщит об ошибке


//* Компонент функции
// Компонент определяется, как функция JS, первым аргументом которой является props объект
// TS требует, чтобы его возвращаемый тип мог быть назначен JSX.Element
// interface FooProp {
//   name: string
//   X: number
//   Y: number
// }
// declare function AnotherComponent(prop: {name: string})
// function ComponentFoo(prop: FooProp) {
//   return <AnotherComponent name={prop.name} />
// }
// const Button = (prop: {value: string}, context: {color: string}) => {
//   <button />
// }

// Поскольку функциональный компонент - это просто функция JS, здесь также могут использоываться прегрузки
// функций:
// interface ClickableProps {
//   children: JSX.Element[] | JSX.Element
// }
// interface HomeProps extends ClickableProps {
//   home: JSX.Element
// }
// interface SideProps extends ClickableProps {
//   side: JSX.Element | string
// }
// function MainButton(prop: HomeProps):  JSX.Element
// function MainButton(prop: SideProps):  JSX.Element
// function MainButton(prop: ClickableProps):  JSX.Element {
// }
// Функциональные элементы раньше имели приписку без сохранения состояния (SFC)
// Поскольку теперь они сохраняют состояние, то тип SFC и его псевдоним StatelessComponent устарели


//* Компонент класса
// Можно определить тип компонента класса. Однако для этого лучше понять два новых термина: тип класса
// элемента и тип класса экземпляра элемента

// Учитывая <Expr />, что тип класса элемента - это тип Expr. Итак, в приведённом выше примере, если бы
// это MyComponent был класс ES6, типом класса был бы конструктор и статика этого класса. Если бы это
// MyComponent была фабричная функция, то эта функция была бы типом класса

// После того, как тип класса установлен, тип экземпляра определяется объединением возвращаемых типов
// конструкции тип класса или сигнатур вызовов (в зависомости от того, что присутствует). Итак, опять же,
// в случае класса ES6 тип экземпляра будет типов экземпляра этого класса, а в случае создателя функции
// это будет тип значения, возвращаемого функцией
class MyComponent2 {
  render() {}
}

var myComponent2 = new MyComponent2()
// element class type => MyComponent2
// element instance type => { render: () => void}

function MyFactoryFunction() {
  return {
    render: () => {}
  }
}
var myComponent2 = MyFactoryFunction()
// element class type => MyFactoryFunction
// element instance type => { render: () => void}

// Тип экземпляра элемента интересен тем, что он должен быть назначен,
//  JSX.ElementClass иначе это приведёт к ошибке
// По умолчанию JSX.ElementClass есть {}, но его можно расширить, чтобы ограничить использование JSX только
//  теми типами, которые соответствуют правильному интерфейсу
declare namespace JSX {
  interface ElementClass {
    render: any
  }
}
class MyComponent3 {
  render() {}
}
function MyFactoryFunction3() {
  return { render: () => {}}
}
{/* <MyComponent3 />
<MyFactoryFunction3 />     - должно быть нормально */}

class NotAValidComponent {}
function NotAValidFactoryFunction() {
  return {}
}
// <NotAValidComponent />
// <NotAValidFactoryFunction />   - ошибки


//* Проверка типа атрибута
// Первым шагом к проверке типов атрибутов является определение типа атрибутов элмента
// Это немного отличается между внутренними и ценностными элементами

// Для внутренних элементов это тип свойства на JSX.IntrinsticElements
declare namespace JSX {
  interface IntrinsticElements {
    foo: {bar?: boolean}
  }
}
// <foo bar />     - работает

// Для элементов, основанных на значениях, это немного сложнее. Он определяется типом свойства в типе
//  экземпляра элемента, который был определён ранее. Какое свойство использовать определяется
//  JSX.ElementAttributesProperty
// Он должен быть объявлен с одним свойством. Затем используется имя этого свойства. Начиная с TS 2.8,
//  если JSX.ElementAttributesProperty не указан, вместо него будет использоваться тип первого параметра
//  конструктора элемента класса или вызова функционального компонента
declare namespace JSX {
  interface ElementAttributesProperty {
    props: any
  }
}
// class MyComponent4 {
//   props: {
//     foo?: string
//   }
// }
// <MyComponent4 foo="bar" /> - работает

// Тип атрибута элемента используется для проверки типа атрибутов в JSX
// Поддерживаются необязательные и обязательные свойства
declare namespace JSX {
  interface IntrinsicElements {
    foo: { requiredProp: string; optionalProp?: number }
  }
}
<foo requiredProp="bar" />; // ok
<foo requiredProp="bar" optionalProp={0} />; // ok
// <foo />; // error, requiredProp is missing
// <foo requiredProp={0} />; // error, requiredProp should be a string
// <foo requiredProp="bar" unknownProp />; // error, unknownProp does not exist
<foo requiredProp="bar" some-unknown-prop />; // ok, because 'some-unknown-prop' is not a valid identifier

// Если имя атрибута не является допустимым идентификатором JS (например, data-* атрибутом),
// это не счиатется ошибкой, если оно не найдено в типе атрибутов элемента

// Кроме того, JSX.IntrinsicAttributes интервейс можно легко использовать для указания дополнительных
// свойств, испольуемых фреймволком JSX, которые обычно не используются реквизитами или аргументами
// компонентов - например, key в React. Более того, универсальный JSX.IntrinsicClassAttributes<T> тип может
// использоваться для указания таких же дополнительных атрибутов только для компонентов класса (а не для
// функциональных компонентов). В этом типе универсальный параметр соответствует типу экземпляра класса.
// В React это используется для разрешения ref атрибута типа Ref<T>. Вообще говоря, все свойства
// в этих интерфейсах должны быть необязательными, если только вы не предполагаете, что пользователям вашей
// JSX-платформы необходимо предоставить какой-либо атрибут для каждого тела

// Оператор спреда тоже работает
var props = {requiredProp: "bar"}
// <foo {...props} />   - должно работать
var badProps = {}
// <foo {...badProps} /> - не работает


//* Проверка типая детей
// В TS 2.3 предоставляется проверка типов дочерних элементов. children - это специальное свойство в типе
// атрибутов элемента, в котором дочение выражения JSXExpression вставляются в атрибуты. Подобно тому,
// как TS использует JSX.ElementAttributesProperty для определения имени реквизита,
// JSX.ElementChildrenAttribute используется для определения имени дочерних элементов в этих реквизитах
// Он должен быть объявлен с одним атрибутом
declare namespace JSX {
  interface ElementChildrenAttribute {
    children: {}
  }
}
<div>
  <h1>Hello</h1>
</div>;
<div>
  <h1>Hello</h1>
  World
</div>;
const CustomComp = (props: any) => <div>{props.children}</div>;
<CustomComp>
  <div>Hello, World</div>
  {"This is just a JS expression..." + 1000}
</CustomComp>;

// Можно указать тип дочерних элементов, как и любой другой атрибут. Это переопределит тип по умолчанию из,
// например, типы React, если вы их используете
// interface PropsType {
//   children: JSX.Element
//   name: string
// }
// class Component extends React.Component<PropsType, {}> {
//   render() {
//     return (
//       <h2>
//         {this.props.children}
//       </h2>
//     )
//   }
// }
// <Component name="foo">
//   <h1>Hello, World</h1>
// </Component>;
// <Component name="bar">
//   <h1>Hello, World</h1>
//   <h2>Hello, World</h2>
// </Component>;
// <Component name="baz">
//   <h1>Hello,</h1>
//   World
// </Component>;


//* Тип результата JSX
// По умолчанию результат выражения JSX имеет вид any. его можно настроить, указав JSX.Element интерфейс
// Однако получить информацию о типе элементов, атрибутов или дочерних элементов JSX из этого интерфейса
// невозможно. Это чёрный ящик


//* Вложение выражений
// JSX позволяет вставлять выражения между тегами, заключая выражения в фигурные скобки
// var z = (
//   <div>
//     { ["foo", "bar"].map(i => (
//       <span>{i / 2}</span>
//     )) }
//   </div>
// )
// Этот код приведёт к ошибке, потому что строку нельзя поделить на число
// Вывод при этой preserve опции выгладит так
// var z = (
//   <div>
//     { ["foo", "bar"].map(function (i) {
//        <span>{i / 2}</span>
//     })}
//   </div>
// )


//* Реагировать на интеграцию
// Чтобы использовать JSX c React, вы должны использовать типизацию React.
// Эти типы определяют JSX пространство имён, подходящее для использования с React
/// <reference path="react.d.ts"/>
// interface Props {
//   foo: string
// }
// class MyComponent5 extends React.Component<Props, {}> {
//   render() {
//     return <span>{this.props.foo}</span>
//   }
// };
// <MyComponent5 foo="bar" />    - должно работать
// <MyComponent5 foo={0} />      - не должно работать


//* Настройка JSX
// Есть несколько флагов компилятора, которые можно использовать для настройки вашего JSX, которые работают
// как флаг компилятора, так и через встроенные прагмы для каждого файлах
// больше можно узнать в tsconfig:
// jsxFactory
// jsxFragmentFactory
// jsxImportSource